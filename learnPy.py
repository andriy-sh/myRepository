S = 'A\nB\tC'
print(S)
print(len(S))

print(ord('\n'))   # ORD возращает значение байта для этого символа СТРОКИ!

D = 'A\0B\0C'   #  \0 не изменяет строку, но длинна самой строки становится не 3 (ABC) а 5!
print(D)



# Продолжение изучения строк
from typing import List

S = 'A\nB\tC'      # \n - перенос на другую строку при выводе, \t - табуляция. Спецсимовлы считаются за символ.

print("Использование переноса и табуляции:\n", S)
print("Длинна со спецсимволами:\n", len(S))      # Спецсимовлы считаются за 1 символ.

print("Значение ASCII слеш n:\n", ord('\n'))   # ORD возращает значение ASCII в байтах для этого символа СТРОКИ!

D = 'A\0B\0C'      # \0 не изменяет строку, но длинна самой строки становится не 3 (ABC) а 5!
print('Использование слеш 0:\n', D)

print('___________________________________________________________________')

# Методы специфичные для строк

L = ['123', 'asdf', '1.245']

print(L)
L.append('NY')     # Добавление єлементов в строку
L.append('5432')
L.append('LOL')
print(L)

L.pop(4)           # 2 способа удаления єлементов строки
del L[1]
print(L)

L.insert(2, 'INSERT')   # Вставляем элемент на конкретную позицию в списке
print(L)
L.remove('LOL')         # Удаляем конкретный элемент по его значению из списка
print(L)

print('___________________________________________________________________')

# поиск по шаблону
import re

match = re.match('Hello[ \t]*(.*)world', 'Hello   Droch search world')
print(match.group(1))

# извлечение груп строковых данных которые размещены между слешами
match = re.match('/(.*)/(.*)/(.*)', '/usr/home/drochnja')
print(match.groups())

print('___________________________________________________________________')

# Вложенные списки

M = [[1,2,3],
     [4,5,6],
     [7,8,9]]  # Выводит в таком виде [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(M)
print(M[1])   # Выводит:  [4, 5, 6]

print(M[1][0])   # Выводит в  1 строке 0-й элемент - 4. Надо учитывать что нумерация начинается с 0


print('___________________________________________________________________')

# Вывод колонки матрицы М

col2 = [row[1] for row in M]

print(col2)   # [2, 5, 8]

print([row[1]/2 for row in M])   # разные мат. операции над елементами колонок матрицы М
print([row[1]*2 for row in M])
print([row[1]**2 for row in M])


print([row[1] for row in M  if row[1] % 2 == 0])  # отфильтровуются только нечетные значения колонки,
#  т.к. берется остаток от деления на 2. Для четных чисел он =0, для нечетных =1.
# Таким образом, если взять ==0, то мы выведем только четные значения, а нечетные не учитываем.

print([row[1] for row in M  if row[1] % 2 == 1])  # тоже самое, но только те значения, где остаток от деление =1,
#  т.е. нечетные значения

diag = [M[i][i] for i in [0, 1, 2]]   # определяю список из элементов в i-й стороки i-ого столбца,
# причем i = 0,1,2. Т.е. получаем список из таких элементов матрицы: {[0][0], [1][1], [2][2]}
print(M)
print('Вывод диагонали:', diag)

r1 = [M[i][0] for i in [0, 1, 2]]   # таким же образом я могу выделить определенный столцеб или строку
s1 = [M[1][i] for i in [0, 1, 2]]
print('Вывод 1 cтолбца:', r1)
print('Вывод 2 строки:', s1)

print('___________________________________________________________________')

doubles = [c * 2 for c in 'spam']   # дублирование каждого элемента строки
print(doubles)

print(M)

G = (sum(row) for row in M)  # Сложение элементов построчно

print(next(G))  # Сложение первой строки
print(next(G))  # Сложение второй строки
print(next(G))  # Сложение 3-й строки. Следующее повторение данной команды привидет к ошибке,
# т.к. строки 4 не существует.

print(list(map(sum, M)))  # заменяет предыдущие команды.


print('___________________________________________________________________')

# СЛОВАРИ

D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}   # Создание словаря и работа с его элементами по ключам

print(D)
print(D['food'])
print(D['quantity'] + 1)

# Метод создания на основе пустого словаря

W = {}
W['name'] = 'Bob'
W['job'] = 'dev'
W['age'] = 40

print(W)

# Вложеные списки и элементы словарей в словарях

rec = {'name': {'first': 'Andriy', 'last': 'Shevchenko'},
       'job': ['dev', 'mgr'],
       'age': 34}
print(rec)
print(rec['name'])             # вложенный словарь
print(rec['name']['last'])     # элемент вложенного словаря
print(rec['job'])              # вложенный список

rec['job'].append('cybersec')   # добавление в словарь новых засписей - расширение словаря

print(rec)

print('___________________________________________________________________')

# КОРТЕЖИ

T = (1, 2, 3, 4, 5)

print(len(T))
print(T[1])
print(dir(T))                    # У кортежей всего 2 базовых метода
print(T)

print('___________________________________________________________________')

# FAILE

# Файл открывается для записи - делается запись - закрывается
f = open('D:\eicar_test.txt', 'w')
f.write('X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*')    # Antivirus test combination
f.close()

f = open('D:\eicar_test.txt')      # Чтение и вывод содержимого файла
text = f.read()
print(text)

text.split()
print(text)

data = open('C:\Windows\System32\esfwdd.bin', 'rb').read()
print(data[15 : 24])
